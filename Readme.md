# Cy-timewheel

基于时间轮的定时器

适用于符合这种描述的任务：“在x时间之后进行某个任务”，而不是“在特定时间执行任务”。

## 1. 实现原理

顾名思义，是基于定时轮的。

关于定时轮的基本思路可以看：https://blog.csdn.net/zhanglh046/article/details/72833172 **但这个项目的实现和它不一样**。

## 2. 一些细节

Slot：即时间轮的每个格子。

Point: 指针，每经过单位时间，这个指针就会往后一个格子偏移。

1. 在上文链接中的实现，对于“跨圈”的处理是使用分层处理的。这个项目中，在每个Slot中都维护了一个```Map<RoundNum, TaskList>```。这个```RoundNum```就表示，这是第几次经过这个格子（可以想象时钟上的秒钟一圈又一圈地经过某个点一样）。

2. 有一个显而易见的原则：进来的任务一定要被执行到。

   为了保证这个原则，一定要获取当前Point的值，根据此来计算所应塞入的值，但由于进来的任务是并行的，所以必须有一个控制机制。

   在之前的实现中，我尝试每个任务进来的时候锁掉Point，但是这样做，会发现锁争抢过多，导致Point的偏移远远延迟与真实时间的走动。

   所以，我在这里是这样实现的：**利用一个后备队列，先收集好进来的任务，然后在每次循环的时候，都从后备队列里获取一个固定数量的任务，然后分别塞进各个Slot**。每次循环都是计时和收集交替进行。

## 3. 待优化点

1. 每次新任务进来的时候，都要new对象，这个可以考虑池化，每次GC消耗的时间，也会造成延迟。